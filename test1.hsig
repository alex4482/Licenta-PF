data Literal = Var String | NotVar String deriving (Eq, Show)

data Clause = Disj Clause Clause | Lit Literal  deriving (Eq, Show)

type Mem = [(String,Bool )]
type Formula = [Clause]

emptyMem :: Mem
emptyMem = [] --holds all literals

negateLit :: Literal -> Literal
negateLit (Var l) = NotVar l
negateLit (NotVar l) = Var l

emptyFormula :: Formula
emptyFormula = []

addClauseToFormula :: Clause -> Formula -> Formula
addClauseToFormula clause formula = formula ++ [clause]

solveFormula :: Formula -> Mem -> Mem
solveFormula f mem = if existsConflict f mem
                    then let (newF, newMem) = solveConflict f mem in solveFormula newF newMem
                    else let (lit, boolean) = findUnassignedLiteral f mem in --boolean is true if there are unassigned literals
                        if boolean
                            then let newMem = propagate f (assignLiteral lit mem)  in solveFormula f newMem 
                            else mem

assignLiteral :: Literal -> Mem -> Mem
assignLiteral (Var literal) mem = (literal, True) : mem --can be made better (not make them automaticaly false)
assignLiteral (NotVar literal) mem = (literal, False) : mem

existsConflict :: Formula -> Mem -> Bool
existsConflict [] _ = False 
existsConflict _ [] = False
existsConflict (clause : formula) mem = isClauseFalse clause mem || existsConflict formula mem
                                    
isClauseFalse :: Clause -> Mem -> Bool
isClauseFalse _ [] = False
isClauseFalse (Lit literal) mem = let (isLitAssigned, litValue) = getLitValueFromMem literal mem in
                             isLitAssigned && litValue
isClauseFalse (Disj cl1 cl2) mem = isClauseFalse cl1 mem || isClauseFalse cl2 mem
--isClauseFalse (Lit (NotVar litName)) mem = let (isLitAssigned, litValue) = getLitValueFromMem litName mem in
--                             isLitAssigned && not litValue
--isClauseFalse (Lit (Var litName)) mem = let (isLitAssigned, litValue) = getLitValueFromMem litName mem in
--                             isLitAssigned && litValue

getLitValueFromMem :: Literal -> Mem -> (Bool, Bool) 
getLitValueFromMem _ [] = (False, False)
getLitValueFromMem (Var myLitName) ( (literalName, literalValue) : remainingMem) = if myLitName == literalName 
                                                                                then (True, literalValue )
                                                                                else getLitValueFromMem (Var myLitName) remainingMem
getLitValueFromMem (NotVar myLitName) ( (literalName, literalValue) : remainingMem) = if myLitName == literalName 
                                                                                then (True, not literalValue )
                                                                                else getLitValueFromMem (NotVar myLitName) remainingMem

propagate :: Formula -> Mem -> Mem
propagate [] mem = mem
propagate clause mem = let (newMem, didPropagate) = propagate' clause mem in
                        if didPropagate 
                            then propagate clause newMem
                            else newMem 

propagate' :: Formula -> Mem -> (Mem, Bool)
propagate' [] mem = (mem, False)
propagate' (clause : remainingFormula) mem = let (newMem, didPropagate) = propagateClause clause mem in
                                        if didPropagate 
                                            then (newMem, True) 
                                            else propagate' remainingFormula mem

propagateClause :: Clause -> Mem -> (Mem, Bool)
propagateClause clause mem = let literals = getUnassignedLiteralsFromClause clause mem in
                                if count literals == 1 || not (isClauseTrueYet clause mem)
                                    then (assignLiteral (head literals) mem, True )
                                    else (mem, False)

isClauseTrueYet :: Clause -> Mem -> Bool
isClauseTrueYet (Lit literal) mem = snd (getLitValueFromMem literal mem)
isClauseTrueYet (Disj cl1 cl2) mem = isClauseTrueYet cl1 mem || isClauseTrueYet cl2 mem

getUnassignedLiteralsFromClause :: Clause -> Mem -> [Literal]
getUnassignedLiteralsFromClause (Lit literal) mem = let (isLitAssigned, litValue) = getLitValueFromMem literal mem in
                                                ([literal | not isLitAssigned ]) --returns literal if it isnt in memory
getUnassignedLiteralsFromClause (Disj cl1 cl2) mem = getUnassignedLiteralsFromClause cl1 mem ++ getUnassignedLiteralsFromClause cl2 mem                                                

findUnassignedLiteral :: Formula -> Mem -> (Literal, Bool) 
findUnassignedLiteral [] _ = (Var "empty", False)
findUnassignedLiteral (clause : remainingFormula) mem = let unasLiterals = getUnassignedLiteralsFromClause clause mem in
                                            if count unasLiterals > 0 
                                                then (head unasLiterals, True)
                                                else findUnassignedLiteral remainingFormula mem
count :: Num p => [a] -> p
count [] = 0             
count (elem : array) = 1 + count array
--count array = foldr (\ elem -> (+) 1) 0 array

--to be added functions 
--solveConflict  [Clause] -> [(String, Bool)] -> ([Clause], [(String, Bool)])
-- !!va trbui sa am grija sa retin ordinea in care am ales literalii neasignati 